# 回文自动机

**回文自动机（也叫回文树）**是一种用于识别一个字符串中所有**本质不同回文子串**的树形数据结构。

由于回文串是前后对称的，因此可以取串的一半来表示整个回文串。当回文串进行拓展时，左半串在首部添加一个字符，右半串在尾部添加一个字符，因此选择易于操作的右半串来表示整个回文串。

与 Trie 类似，PAM 上的每个节点表示一个回文串。用 $S(u)$ 表示节点 $u$ 代表的回文串，从根节点到节点 $u$ 的所有字符按顺序连接成的字符串表示回文串 $S(u)$ 的后半部分。$len[u] = \vert S(u) \vert$。

PAM 上每个节点通过若干条**后继边**指向新节点，新节点代表的回文串等价于在父节点的回文串首尾各添加一个后继边上的字符。若节点 $u$ 通过字符 $ch$ 表示的边指向节点 $v$，则 $S(v) = \textbf{ch} + S(u) + \textbf{ch}$，$len[v] = len[u] + 2$。

但由于奇回文串和偶回文串的中心字符个数不同，在拓展时的操作不完全相同，所以我们将回文树设立两个根节点，**奇根**和**偶根**。由两个根拓展出的回文串分别为偶回文串和奇回文串。其中偶根的长度为 $0$；而奇根是一个实际不存在的虚根，其长度设为 $-1$，这样做的意义是从奇根拓展出一个回文串时，该回文串的长度为 $-1 + 2 = 1$，即通过删去一个中心字符来表示奇回文串。

~~或者也可以像 Mancher 算法那样将所有回文串预处理成奇回文串。~~

PAM​ 上的每个节点都有一个**失配边**，指向回文串匹配失败时跳转的位置。若 $fail[u] = v$，则 $S(v)$ 是 $S(u)$ 的最大回文 border。

## 构建 PAM

虽然PAM是基于单个模式串构建的数据结构，但它记录的是字符串上左右的本质不同回文串，因此 PAM 是一个字典，无论是从功能还是构建方式上来看，比起 KMPAM，它与 ACAM 更为相似。

类似于 ACAM 的构建过程，根据**后继边**的概念，构建 PAM 的过程实际上是求字符串上每个位置前缀串的**最大回文 border**，在此基础上拓展出新串。方法是先找到前一个位置在 PAM 上的位置，然后按照 fail 链枚举所有的回文 border，直到该 border 可以通过当前字符 $ch$ 表示的边向两侧拓展。

当一个串的最大border为 $0$ 时，此时 fail 指针应当指到偶根的位置，回文串要拓展的位置时前缀串的最后一个字符 $S[i - 1]$。若 $S[i - 1] = S[i]$，则从偶根通过边 $S[i]$ 拓展出一个回文串；但如果不匹配，此时出现的应该是长度为 $1$，只包含一个字符 $S[i]$ 的回文串，应当从奇根拓展出来。为解决以上需求，我们定义**偶根的 fail 指针指向奇根**。~~奇根的 fail 指针实际上没有意义，为方便使用指向自己。~~

不同于 Manacher，由于 PAM 每次处理新字符只依赖已处理前缀信息，因此支持在模式串的结尾的**在线增量构建**。每次追加新字符时只需从上一个字符出发延 fail 链查找位置建立新节点即可。

```c++
root0->fail = root1;
root0->len =  0;
root1->fail = root1;
root1->len = -1;
```

```c++
void add(char c)
{
	int loc = pattern.length();
	int index = c - 'a';
	pattern += c;
	// 延 fail 链找到要转移的位置
	while (loc - last->len - 1 < 0 || pattern[loc - last->len - 1] != c)
	{
		last = last->fail;
	}
	if (last->nexts[index] == nullptr)
	{
		Node* node = new Node;
		node->len = last->len + 2;
		last->nexts[index] = node;
		// 找到位置之后设置 fail 指针
		if (node->len == 1)
		{
			node->fail = root0;
		}
		else
		{
			Node* n = last->fail;
			while (loc - n->len - 1 < 0 || pattern[loc - n->len - 1] != c)
			{
				n = n->fail;
			}
			node->fail = n->nexts[index];
		}
	}
	// 更新模式串最后一个位置对应的树上节点
	last = last->nexts[index];
}
```

根据实际需要，PAM 上的节点可记额外记录每个回文串的出现次数 $count$ 和在当前位置出现的回文串个数 $count\_end$。

----

# 模板

## 指针版

```c++
class PAM
{
private:
	struct Node
	{
		array<Node*, 26> nexts{};
		Node* fail{nullptr};
		int len{0};
		int count_end{0};	// 在每个位置有多少个结束的回文串
		int count{0};		// 当前回文串出现的次数
	};

	Node* root0{nullptr};
	Node* root1{nullptr};

	string pattern{};
	Node* last{nullptr};

public:
	PAM() : root0{new Node}, root1{new Node}, last{root0}
	{
		root0->fail = root1;
		root0->len =  0;
		root1->fail = root1;
		root1->len = -1;
	}

	~PAM()
	{
		queue<Node*> q;
		q.push(root0);
		q.push(root1);
		while (!q.empty())
		{
			Node* u = q.front();
			q.pop();
			for (Node* v : u->nexts)
			{
				if (v != nullptr)
					q.push(v);
			}
			delete u;
		}
	}

public:
	void add(string &s)
	{
		for (char c : s)
		{
			add(c);
		}
	}

	void add(char c)
	{
		int loc = pattern.length();
		int index = c - 'a';
		pattern += c;
		// 延 fail 链找到要转移的位置
		while (loc - last->len - 1 < 0 || pattern[loc - last->len - 1] != c)
		{
			last = last->fail;
		}
		if (last->nexts[index] == nullptr)
		{
			Node* node = new Node;
			node->len = last->len + 2;
			last->nexts[index] = node;
			// 找到位置之后设置 fail 指针
			if (node->len == 1)
			{
				node->fail = root0;
			}
			else
			{
				Node* n = last->fail;
				while (loc - n->len - 1 < 0 || pattern[loc - n->len - 1] != c)
				{
					n = n->fail;
				}
				node->fail = n->nexts[index];
			}
			node->count_end = node->fail->count_end + 1;
		}
		// 更新模式串最后一个位置对应的树上节点
		last = last->nexts[index];
		++last->count;
	}
};
```

## 数组版

```c++
class PAM
{
private:
	struct Node
	{
		array<int, 26> nexts{};
		int fail{0};
		int len{0};
		int count_end{0};
	};

	// 0 号节点和 1 号节点分别作为偶根和奇根
	vector<Node> tree{{{}, 1, 0, 0}, {{}, 1, -1, 0}};

	string pattern{};
	int last{0};

public:
	PAM()
	{}

public:
	void add(string &s)
	{
		for (char c : s)
		{
			add(c);
		}
	}

	void add(char c)
	{
		int loc = pattern.length();
		int index = c - 'a';
		pattern += c;
		// 延 fail 链找到要转移的位置
		while (loc - tree[last].len - 1 < 0 || pattern[loc - tree[last].len - 1] != c)
		{
			last = tree[last].fail;
		}
		if (tree[last].nexts[index] == 0)
		{
			int node = tree.size();
			tree.emplace_back();
	
			tree[node].len = tree[last].len + 2;
			tree[last].nexts[index] = node;
			// 找到位置之后设置 fail 指针
			if (tree[node].len == 1)
			{
				tree[node].fail = 0;
			}
			else
			{
				int n = tree[last].fail;
				while (loc - tree[n].len - 1 < 0 || pattern[loc - tree[n].len - 1] != c)
				{
					n = tree[n].fail;
				}
				tree[node].fail = tree[n].nexts[index];
			}
			tree[node].count_end = tree[tree[node].fail].count_end + 1;
		}
		// 更新模式串最后一个位置对应的树上节点
		last = tree[last].nexts[index];
		++tree[last].count;
	}
};
```

---

# 例题

[P5496 【模板】回文自动机（PAM） - 洛谷](https://www.luogu.com.cn/problem/P5496)（模板）

