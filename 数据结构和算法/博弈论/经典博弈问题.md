# Bash Game

一共 $n$ 颗石子，两个人轮流拿走，每次可拿走 $1$ ~ $m$ 颗，拿走最后一颗石子的玩家获胜。

## 推导

只剩 $0$ 颗石子时，此时的玩家处于必败态。

对于任意非零颗石子，此时的玩家如果能使下一个玩家进入必败态，则该玩家处于必胜态，否则该玩家处于必败态。

```c++
bool game(int n, int m)
{
	vector<bool> willwin(n + 1, false);
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= m; ++j)
		{
			if (i - j < 0)
				break;
			if (willwin[i - j] == false)
				willwin[i] = true;
		}
	}
	return willwin[n];
}
```

## 结论

如果 $n \% (m + 1) \neq 0$，先手胜，否则后手胜。

```c++
bool game(int n, int m)
{
	return n % (m + 1) != 0;
}
```

## 例题

[P4018 Roy&October之取石子 - 洛谷](https://www.luogu.com.cn/problem/P4018)(Bash Game 拓展)

# Nim Game

有 $n$ 堆石头，每堆有若干颗石头，每人每次可从任意一个非空的石头堆中拿走任意正数颗石头，拿走最后一颗石头的玩家获胜。

## 推导

最终状态是所有堆的石子个数都为 $0$，为必败态。此时所有堆的石子个数的异或和为 $0$。

当若干个数的异或和为 $0$ 时，将任意一个数减小一部分，得到的异或和一定不为 $0$；当若干个数的异或和不为 $0$ 时，一定存在一种方案使得将一个数减小一部分之后的异或和为 $0$。

若想取胜，最佳方案是始终让对方所在的状态是所有数异或和为 $0$，前提是自己所在的状态所有数异或和不为 $0$，否则对方会让自己的所有状态异或和都为 $0$。因此初始时所有数异或和若不为 $0$ 则处于必胜态，否则处于必败态。

## 结论

如果 $\bigoplus_{i = 1}^{n} m \neq 0$，先手胜。否则后手胜。

```c++
bool game(vector<int> &v)
{
	int flag = 0;
	for (int i : v)
	{
		flag ^= i;
	}
	return flag != 0;
}
```

## 例题

[P2197 【模板】Nim 游戏 - 洛谷](https://www.luogu.com.cn/problem/P2197)（模板）